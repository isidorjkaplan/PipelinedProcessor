#include <stdio.h>

#include <stdlib.h>

#include <math.h>

#include <float.h>

#include "altera_avalon_performance_counter.h"

#include <sys/alt_irq.h>

#include <assert.h>



static alt_irq_context context; /* Use when disabling interrupts. */



static void pre_measurement(void){

  PERF_RESET (PERFORMANCE_COUNTER_0_BASE);

  context = alt_irq_disable_all();

  PERF_START_MEASURING (PERFORMANCE_COUNTER_0_BASE);

}



static void post_measurement(void){

	alt_irq_enable_all(context);

	PERF_STOP_MEASURING (PERFORMANCE_COUNTER_0_BASE);

}



static inline int get_runtime(int sec) {

	return (int)perf_get_section_time ((void*)PERFORMANCE_COUNTER_0_BASE, sec);

}



/*Boilerplate fixed-point code*/



typedef int fixed;



int Q_M = 0;

int Q_N = 0;

int F_ONE = 0;



void SET_Q_FORMAT(int M, int N) {

    Q_M = M;

    Q_N = N;

    F_ONE = 1 << N;

}



fixed FLOAT_TO_FIXED(float f) {

    return (fixed)(f * F_ONE);

}



float FIXED_TO_FLOAT(fixed f){

    return (float)(f)/F_ONE;

}



fixed FIXED_MULT(fixed op1, fixed op2) {

    return (fixed)op1*op2 >> Q_N;

}



float float_abs(float x) {

    if (x >= 0) return x;

    else return -x;

}





/*DCT code - FLOATING*/

#define MAX_SIZE 64

#define COS_TERMS 2*MAX_SIZE

#define FLOAT_PI 3.14159265

#define NBITS 16

float cos_terms[COS_TERMS];

fixed cos_q15[COS_TERMS];



void ALLOC_DCT_PRECOMP_ARRAY() {

    int i;

    //for ((i,int(math.cos(math.pi*float(i)/MAX_SIZE)*(1<<(NBITS-1)))))

    for (i = 0; i < COS_TERMS; i++) {

        cos_terms[i] = cos(FLOAT_PI * i / MAX_SIZE);

        cos_q15[i] = (int)(cos_terms[i]*(1<<(NBITS-1)));

    }

}



void dct_float_raw(float* signal, float* result, int N) {

    for (int K = 0; K < N; K++) {

        result[K] = 0;

        for (int n = 0; n < N; n++) {

            result[K] += signal[n] * cos((FLOAT_PI/N)*(n+0.5)*K);

        }

    }

}



int num_fixed;

int num_float;

int num_unit;



void dct_float(float* signal, float* result, int N) {

    num_float++;

    int power = (int)log2(N);

    assert(powl(2,power) == N);//must be power of 2 for the optimized version

    PERF_BEGIN (PERFORMANCE_COUNTER_0_BASE, 2);

    for (int K = 0; K < N; K++) {

        result[K] = 0;

        for (int n = 0; n < N; n++) {

            // signal[n]*cos_q15[(((2*n+1) * K * MAX_SIZE) >> (power+1)) & (COS_TERMS - 1)] >>> (NBITS-1);

            result[K] += signal[n] * cos_terms[(((int)((n+0.5)*K*MAX_SIZE))>>power) & (COS_TERMS-1)];

        }

    }

    PERF_END (PERFORMANCE_COUNTER_0_BASE, 2);

}



void dct_fixed(fixed* signal, fixed* result, int N) {

    num_fixed++;

    int power = (int)log2(N);

    assert(powl(2,power) == N);//must be power of 2 for the optimized version

    PERF_BEGIN (PERFORMANCE_COUNTER_0_BASE, 1);

    for (int K = 0; K < N; K++) {

        result[K] = 0;

        for (int n = 0; n < N; n++) {

            // signal[n]*cos_q15[(((2*n+1) * K * MAX_SIZE) >> (power+1)) & (COS_TERMS - 1)] >>> (NBITS-1);

            result[K] += (signal[n] * cos_q15[(((int)((n+0.5)*K*MAX_SIZE))>>power) & (COS_TERMS-1)]) >> (NBITS-1);

        }

    }

    PERF_END (PERFORMANCE_COUNTER_0_BASE, 1);

}



volatile int* dct_write_q = (int*) (AVALON_DCT_NIOS_0_BASE + 8);

volatile int* dct_write_size = (int*) (AVALON_DCT_NIOS_0_BASE);

volatile int* dct_write_data = (int*) (AVALON_DCT_NIOS_0_BASE + 4);



int main(void) {

    *dct_write_q = 5;

    *dct_write_size = 3;

    for (int i = 0; i < 8; i++) {

        *dct_write_data = 0;

    }

    int value = *dct_write_size;

    printf("First Term: %x", value);

    return 0;

}
